package org.point85.ua;

import java.time.ZonedDateTime;

import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.point85.open62541.Open62541ExtLibrary;
import org.point85.open62541.Open62541ExtLibrary.UA_Client;
import org.point85.open62541.Open62541ExtLibrary.UA_StatusCode;
import org.point85.open62541.UA_BrowseResponse;
import org.point85.open62541.UA_BrowseResult;
import org.point85.open62541.UA_DataValue;
import org.point85.open62541.UA_NodeId;
import org.point85.open62541.UA_NodeId.identifierType_enum;
import org.point85.open62541.UA_ReadResponse;
import org.point85.open62541.UA_ReferenceDescription;
import org.point85.open62541.UA_ResponseHeader;
import org.point85.open62541.UA_String;
import org.point85.open62541.UA_Variant;
import org.point85.open62541.UA_WriteResponse;

/**
 * This class is a client for an OPC UA server. It is based on the Open62541
 * project along with a wrapper shared library. Calls into the shared library
 * are synchronized assuming that the library (C code) is not thread safe. The
 * java client stubs are generated by the JNA project using the Bridj mode.
 * 
 * Limitations:  
 * 	(1) anonymous login only
 * 	(2) arrays and matrix data not supported.
 **/
public class UaClient {

	// wrapped client
	private Pointer<UA_Client> client;

	// connection flag
	boolean isConnected = false;

	public UaClient() {
		// create client
		client = Open62541ExtLibrary.createClient();
	}

	/**
	 * Delete the client
	 * 
	 * @throws UaException
	 *             An exception
	 **/
	public synchronized void delete() throws UaException {
		if (client != null) {

			if (isConnected) {
				disconnect();
			}
			Open62541ExtLibrary.deleteClient(client);
		}
	}

	/**
	 * Connect to the UA server
	 * 
	 * @param serverUrl
	 *            Server URL
	 * @throws UaException
	 *             An exception
	 */
	public synchronized void connect(String serverUrl) throws UaException {
		Pointer<Byte> endpointUrl = Pointer.pointerToBytes(serverUrl.getBytes());

		IntValuedEnum<UA_StatusCode> status = Open62541ExtLibrary.connectClient(client, endpointUrl);

		if (status != UA_StatusCode.UA_STATUSCODE_GOOD) {
			throw new UaException("Bad connect status: " + UaUtils.convertStatusToHexCode(status));
		}

		isConnected = true;
	}

	/**
	 * Disconnect from the server
	 * 
	 * @throws UaException
	 *             An exception
	 */
	public synchronized void disconnect() throws UaException {
		if (!isConnected) {
			return;
		}

		IntValuedEnum<UA_StatusCode> status = Open62541ExtLibrary.disconnectClient(client);

		if (status != UA_StatusCode.UA_STATUSCODE_GOOD) {
			throw new UaException("Bad disconnect status: " + UaUtils.convertStatusToHexCode(status));
		}

		isConnected = false;
	}

	// Extract the data variant out of the read response
	private UA_Variant getVariant(Pointer<UA_ReadResponse> readResponse) throws UaException {
		UA_Variant uaVariant = null;
		UA_ResponseHeader responseHeader = readResponse.get().responseHeader();

		if (responseHeader.serviceResult() != UA_StatusCode.UA_STATUSCODE_GOOD) {
			throw new UaException("Bad response status code: " + responseHeader.serviceResult());
		}

		if (readResponse.get().resultsSize() <= 0) {
			throw new UaException("No results for the read.");
		}

		UA_DataValue dataValue = readResponse.get().results().get();

		if (!dataValue.hasValue()) {
			// expected if reading a folder node?
			return uaVariant;
		}

		if (dataValue.status() != UA_StatusCode.UA_STATUSCODE_GOOD) {
			// expected if reading a folder node?
			return uaVariant;
		}

		return dataValue.value();
	}

	/**
	 * Synchronously read the value a node. The node must have its name space
	 * index and identifier set prior to this call.
	 * 
	 * @param node
	 *            {@link UaNode}
	 * @throws UaException
	 *             An exception
	 */
	public synchronized void read(UaNode node) throws UaException {

		if (node == null) {
			return;
		}
		Pointer<UA_NodeId> nodeToRead = UaUtils.uaNodeIdFromNode(node);

		// call into the dll
		Pointer<UA_ReadResponse> response = Open62541ExtLibrary.synchRead(client, nodeToRead);

		// set data into the node
		UA_Variant variant = getVariant(response);
		node.setVariantData(variant);

		// TODO: verify that the variant is deleted too, or change dll's memory
		// handling
		Open62541ExtLibrary.deleteReadResponse(response);
	}

	/**
	 * Synchronously browse a node with children. The browsed data is set into
	 * the UaNode.
	 * 
	 * @param parentNode
	 *            Parent {@link UaNode}
	 * @throws UaException
	 *             An exception
	 */
	public synchronized void browse(UaNode parentNode) throws UaException {
		if (parentNode == null) {
			return;
		}

		short nodeNSIndex = parentNode.getMainNodeId().getNamespaceIndex();
		IntValuedEnum<identifierType_enum> typeEnum = parentNode.getMainNodeId().getTypeEnum();

		Pointer<UA_NodeId> parentNodeId = null;
		Pointer<UA_String> pStringId = null;

		// numeric node
		if (typeEnum.equals(UA_NodeId.identifierType_enum.UA_NODEIDTYPE_NUMERIC)) {
			int numericId = parentNode.getMainNodeId().getNumericIdentifier();
			parentNodeId = Open62541ExtLibrary.createNumericNodeId(nodeNSIndex, numericId);
		}

		// string node
		else if (typeEnum.equals(UA_NodeId.identifierType_enum.UA_NODEIDTYPE_STRING)) {
			String stringId = parentNode.getMainNodeId().getStringIdentifier();
			pStringId = UaUtils.uaStringFromString(stringId);
			parentNodeId = Open62541ExtLibrary.createStringNodeId(nodeNSIndex, pStringId);

		} else {
			throw new UaException("Unsupported node type: " + typeEnum);
		}

		// call into the dll
		Pointer<UA_BrowseResponse> browseResponse = Open62541ExtLibrary.browseNode(client, parentNodeId);
		UA_BrowseResponse response = browseResponse.get();
		UA_ResponseHeader responseHeader = response.responseHeader();

		if (responseHeader.serviceResult() != UA_StatusCode.UA_STATUSCODE_GOOD) {
			throw new UaException("Bad browsed status code: " + responseHeader.serviceResult());
		}

		// get the browse results
		Pointer<UA_BrowseResult> pResult = response.results();
		int bound = response.resultsSize();

		// iterator has an unknown bound, so keep a counter
		int loopCount = 0;

		for (UA_BrowseResult browseResult : pResult) {
			if (loopCount == bound) {
				break;
			}

			loopCount++;

			int innerBound = browseResult.referencesSize();
			Pointer<UA_ReferenceDescription> pRef = browseResult.references();

			if (pRef == null) {
				continue;
			}

			// get the data from the reference description
			inspectReferenceDescription(pRef, innerBound, parentNode);
		}

		if (pStringId != null) {
			pStringId.release();
		}

		return;
	}

	// extract the reference information from the UA_ReferenceDescription and
	// set it into a child node
	private void inspectReferenceDescription(Pointer<UA_ReferenceDescription> pDescription, int bound,
			UaNode parentNode) throws UaException {

		int loopCount = 0;
		for (UA_ReferenceDescription description : pDescription) {

			// bound the iteration
			if (loopCount == bound) {
				break;
			}
			loopCount++;

			// node id
			UA_NodeId nodeId = description.nodeId().nodeId();
			short nodeNSIndex = nodeId.namespaceIndex();
			IntValuedEnum<identifierType_enum> typeEnum = nodeId.identifierType();

			UaNode childNode = null;

			// numeric node to read
			if (typeEnum.equals(UA_NodeId.identifierType_enum.UA_NODEIDTYPE_NUMERIC)) {

				int nodeNumericId = nodeId.identifier().numeric();

				childNode = new UaNode(nodeNSIndex, nodeNumericId);

			} // string node to read
			else if (typeEnum.equals(UA_NodeId.identifierType_enum.UA_NODEIDTYPE_STRING)) {

				UA_String nodeStringId = nodeId.identifier().string();

				String stringId = UaUtils.stringFromUaString(nodeStringId);
				childNode = new UaNode(nodeNSIndex, stringId);
			}

			// read the child node
			read(childNode);

			// read deletes the nodeId
			childNode.setReferenceData(description);
			parentNode.getChildren().add(childNode);

		} // end reference loop
	}

	/**
	 * Synchronously write a value to a node
	 * 
	 * @param node
	 *            {@link UaNode} to write to
	 * @param value
	 *            Value to write
	 * @throws UaException
	 *             An exception
	 */
	public synchronized void write(UaNode node, Object value) throws UaException {
		if (node == null || value == null) {
			return;
		}
		Pointer<UA_Variant> valueToWrite = null;

		// TODO: support remaining types
		if (value instanceof Boolean) {
			valueToWrite = Open62541ExtLibrary.createScalarVariant((short) Open62541ExtLibrary.UA_TYPES_BOOLEAN,
					Pointer.pointerToBoolean((Boolean) value));

		} else if (value instanceof Byte) {

			valueToWrite = Open62541ExtLibrary.createScalarVariant((short) Open62541ExtLibrary.UA_TYPES_BYTE,
					Pointer.pointerToByte((Byte) value));

		} else if (value instanceof Short) {
			valueToWrite = Open62541ExtLibrary.createScalarVariant((short) Open62541ExtLibrary.UA_TYPES_INT16,
					Pointer.pointerToShort((Short) value));

		} else if (value instanceof Integer) {
			valueToWrite = Open62541ExtLibrary.createScalarVariant((short) Open62541ExtLibrary.UA_TYPES_INT32,
					Pointer.pointerToInt((Integer) value));

		} else if (value instanceof Long) {
			valueToWrite = Open62541ExtLibrary.createScalarVariant((short) Open62541ExtLibrary.UA_TYPES_INT64,
					Pointer.pointerToLong((Long) value));

		} else if (value instanceof Float) {
			valueToWrite = Open62541ExtLibrary.createScalarVariant((short) Open62541ExtLibrary.UA_TYPES_FLOAT,
					Pointer.pointerToFloat((Float) value));

		} else if (value instanceof Double) {
			valueToWrite = Open62541ExtLibrary.createScalarVariant((short) Open62541ExtLibrary.UA_TYPES_DOUBLE,
					Pointer.pointerToDouble((Double) value));

		} else if (value instanceof String) {
			Pointer<UA_String> uaString = UaUtils.uaStringFromString((String) value);

			valueToWrite = Open62541ExtLibrary.createScalarVariant((short) Open62541ExtLibrary.UA_TYPES_STRING,
					uaString);

		} else if (value instanceof ZonedDateTime) {
			long uaDateTime = UaUtils.uaDateTimeFromTime((ZonedDateTime) value);
			valueToWrite = Open62541ExtLibrary.createScalarVariant((short) Open62541ExtLibrary.UA_TYPES_DATETIME,
					Pointer.pointerToLong(uaDateTime));
		} else {
			System.out.println("Unrecognized object class" + value.getClass().getSimpleName());
			return;
		}

		Pointer<UA_NodeId> nodeToWrite = UaUtils.uaNodeIdFromNode(node);

		// call into the dll
		Pointer<UA_WriteResponse> response = Open62541ExtLibrary.synchWrite(client, nodeToWrite, valueToWrite);

		// inspect the response header
		UA_ResponseHeader responseHeader = response.get().responseHeader();

		if (responseHeader.serviceResult() != UA_StatusCode.UA_STATUSCODE_GOOD) {
			throw new UaException(
					"Bad status code on write: " + UaUtils.convertStatusToHexCode(responseHeader.serviceResult()));
		}

		// set data back into the node
		node.setVariantData(valueToWrite.get());

		Open62541ExtLibrary.deleteWriteResponse(response);
		Open62541ExtLibrary.deleteVariant(valueToWrite);
	}
}
